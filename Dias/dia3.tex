\documentclass[10pt,letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{float}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Rony J. Letona}
\title{Taller de Qu\'imica Computacional Aplicada: D\'ia 3}
\definecolor{light-gray}{gray}{0.90}

\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inlinecode}[1]{
\colorbox{light-gray}{\texttt{#1}}
}

\newsavebox{\selvestebox}
\newenvironment{Code}
{
\begin{lrbox}{\selvestebox}%
\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}
\fontfamily{\ttdefault}\selectfont
}
{\end{minipage}\end{lrbox}%
\begin{center}
\colorbox{light-gray}{\usebox{\selvestebox}}
\end{center}
}

\newcommand{\Picture}[1]
{
	\begin{figure}[H]
	\begin{flushleft}
	\includegraphics[width=\columnwidth]{#1}
	\end{flushleft}
	\end{figure}
}

\begin{document}
\maketitle

\section{Ejercicios con el Sistema de Control de Revisi\'on - Git}
Al comenzar a trabajar en un proyecto en computaci\'on, generalmente se trabaja con archivos sencillos de texto. Estos tienen el c\'odigo que escribimos y al compilarlos/interpretarlos y ejecutarlos, resultan en programas. Todo funciona as\'i. A veces el c\'odigo en los archivos es comprensible, a veces no lo es porque no es para que lo entendamos nosotros sino el ordenador. Sin embargo, a todos nos ha pasado que borramos un archivo importante o que cambiamos algo que no deb\'iamos de cambiar y no hay manera de recuperarlo. Desde documentos como reportes de laboratorio hasta cartas, siempre nos pasa en alguna ocasi\'on que perdemos informaci\'on importante. Para ello se dise\~n\'o una alternativa.\\

Git es la soluci\'on m\'as eficiente para ello. Es un sistema en el que cada revisi\'on o versi\'on de un archivo se va guardando gradualmente, se lleva registro de cu\'ales cambios se hicieron y de cu\'ando se hicieron. Es el cuaderno de laboratorio digital! No nos salvar\'a una tarea si repentinamente desconectamos el ordenador o se interrumpe la energ\'ia el\'ectrica. Es un sistema para llevar autom\'aticamente registro del trabajo realizado. Lo usan grandes empresas, as\'i como peque\~nas iniciativas en sus proyectos. Y no se tiene que limitar a software, puede tratarse de libros, art\'iculos, bases de datos peque\~nas y cualquier otra cosa que sufra cambios con el tiempo o requiera ser compartida. Por ello, y por otras razones que veremos m\'as adelante, vamos a hacer algunos ejercicios con el sistema git.

\subsection{Configuraci\'on de Git}
Lo primero que debemos hacer con una nueva pieza de software es configurarla. Por ello, vamos a aprender sobre algunas de las cosas importantes que debemos tener para comenzar. Es importante que nuestro trabajo tenga nuestro nombre y que d\'e una direcci\'on para contactarnos en caso de que alguien desee hacerlo. Adem\'as de eso, es importante que git nos pueda ofecer un editor de texto para hacer cambios en los registros de cada revisi\'on. Comencemos pues con el c\'odigo.\\

Abre una l\'inea de comando e ingresa lo siguiente. Claro, cambia el nombre por el tuyo y la direcci\'on de email por la tuya tambi\'en.

\begin{Code}
git config --global user.name "Tu Nombre"\\
git config --global user.email "tu\_direccion\_de@email.com"\\
git config --global color.ui "\ \hspace*{-1em} auto"\\
git config --global core.editor "nano"
\end{Code}

Con esto ya configuramos git; no necesitamos hacer esto nunca en nuestro ordenador. Revisando r\'apidamente lo que hicimos, porque no vamos a entrar mucho en detalle, debemos notar que cada comando de git se escribe de la siguiente forma \inlinecode{git \emph{verbo}}. Al principio se anuncia que vamos a trabajar con git, luego el \emph{verbo} especifica lo que vamos a hacer. Lo dem\'as ya son par\'ametros. Ahora procederemos a practicar un poco con git.
\pagebreak
\subsection{Creando y Clonando un Repositorio}
Como cualquier nuevo proyecto en un laboratorio, vamos a inaugurarlo con un cuaderno nuevo: vamos a crear un repositorio nuevo localmente. Para ello crearemos un nuevo directorio y luego iniciaremos git dentro de \'el.

\begin{Code}
mkdir "Mi Proyecto"\\
cd "Mi Proyecto"\\
git init
\end{Code}

Si observamos el contenido del directorio con \inlinecode{ls}, notaremos que no hay nada aparentemente en \'el. Sin embargo, si ingresamos el comando \inlinecode{ls -a} para mostrar \emph{todos} los contenidos en el directorio (hasta los ocultos), nos daremos cuenta de que existe ahora un directorio \inlinecode{.git} en donde se ir\'a guardando el registro de cada revisi\'on de nuestro trabajo.\\

Otra forma de hacer esto, y de hecho la m\'as c\'omoda, es crear un repositorio en GitHub y luego clonarlo a nuestro ordenador. Antes de comenzar con esta parte, aseg\'urate de tener una cuenta en GitHub. Luego, vamos a crear un nuevo repositorio presionando el bot\'on de ``New repository'' que sale al presionar el \textbf{+} en la esquina superior derecha.\\

\Picture{img/github1.png}

Luego vamos a crear un nuevo proyecto. Este va a contener todos los archivos y peque\~nos ejercicios que vamos a ir realizando durante todo el taller. Es por ello que lo vamos a nombrar \textbf{TQCA-ej}. Claro que podemos ponerle cualquier nombre, pero en este caso caso solo buscamos un lugar para llevar registro de todo el taller. Inmediatamente despu\'es hay un espacio para colocar la descripci\'on del proyecto. Coloca all\'i lo que desees. Luego nos damos cuenta de que podemos tenerlo como p\'ublico (a la vista del mundo) o privado (tenerlo privado implica el cobro de una mensualidad). Imagino que vamos a tenerlo p\'ublico. A continuaci\'on se nos ofrece la posibilidad de incluir un archivo README. Este es una forma de instructivo sobre qu\'e es y c\'omo funciona el proyecto. Adem\'as, permite que el proyecto sea clonado. Por ello, vamos a activar la casilla. Finalmente se puede activar el tener un archivo \inlinecode{.gitignore}, el cual no vamos a tener ahorita, y una licencia. El tema de las licencias lo tocaremos m\'as adelante en el taller, por lo que esto tambi\'en lo podemos dejar sin crear.\\

\Picture{img/github2.png}

Finalmente ingresamos a nuestro nuevo repositorio y vemos que en \'el se hallan varias cosas como el nombre, los archivos en \'el, la descripci\'on y una serie de opciones al lado derecho. A nosotros ahora nos interesa la opci\'on que dice \emph{\textbf{HTTPS} clone URL} en la esquina inferior derecha. Vamos a hacer click en el bot\'on al final del campo de texto. Ahora, despu\'es de nuestra vuelta por GitHub, vamos a iniciar el proyecto en nuestro ordenador. Para ello vamos a clonar el proyecto de GitHub de la siguiente manera: en la l\'inea de comando escribe \inlinecode{git clone} y pega la direcci\'on que acabas de copiar. Al presionar Enter, te dar\'as cuenta de que el proyecto se habr\'a copiado a un nuevo directorio con el nombre del proyecto. Ahora ya puedes trabajar tu proyecto de GitHub en tu ordenador.

\subsection{Estado, Diferencias e Ignorados}
Entre las operaciones b\'asicas que se pueden hacer \emph{antes} de guardar un registro, est\'an la revisi\'on del estado del mismo, las diferencias halladas en los archivos del proyecto y qu\'e archivos no se deben de tomar en cuenta en el registro de una revisi\'on. Quiz\'a ahorita no sea tan evidente el uso de estas funciones, pero a la hora de ya estar trabajando en un proyecto y de tener que llevar registro de varias revisiones por varias personas trabajando en el mismo proyecto, estas funciones comienzan a tornarse muy \'utiles en la manipulaci\'on de git.

\subsubsection{status}
Para comenzar con esta parte, ser\'ia conveniente que copiaras todos los archivos que has producido anteriormente en el directorio del proyecto. As\'i podremos demostrar el uso de diferentes t\'ecnicas en git que nos permitir\'an trabajar mejor con las revisiones. Ahora, despu\'es de haberlos copiado, nos disponemos a revisar qu\'e dice git de estos cambios. Para ello ingresamos en la l\'inea de comando \inlinecode{git status}.\\

Lo que git nos dice ahora es que hay nuevos archivos que no han sido agregados al registro de esa revisi\'on. Esto significa que s\'i son parte del proyecto, pero git no sabe si debe de registrarlos y \emph{seguirlos}. Inmediatamente se nos dice tambi\'e c\'omo se agregan estos a esta revisi\'on: \inlinecode{git add \emph{nombre\_del\_archivo.ext}}. Si dese\'aramos agregar m\'as de un archivo, podemos solo agregar el nombre del archivo despu\'es del primero as\'i: \inlinecode{git add \emph{archivo1.txt} \emph{archivo2.txt} \emph{archivo3.txt}} Ahora vamos a volver a correr \inlinecode{git status} para revisar qu\'e ha pasado. Nos topamos con que los arhivos que hemos agregado ya est\'an listos para ser registrados.\\

Finalmente, vamos a guardar este registro. Por ahora solo lo haremos sin mayor explicaci\'on; m\'as adelante comprenderemos en su totalidad qu\'e es lo que hace el siguiente comando. Ingresa en la l\'inea de comando lo siguiente: \inlinecode{git commit -m "Probando agregar archivos"} y listo. Con esto hemos creado el registro de nuestra primera revisi\'on en git con los archivos que hemos agregado.

\subsubsection{diff}
Una cosa es agregar y quitar archivos. Otra cosa es editarlos. Vamos a ingresar a alguno de nuestros archivos y vamos a cambiar algo peque\~no en \'el. Busca alg\'un dato que puedas cambiar, sin miedo, y c\'ambialo. Ahora, vamos a volver a repetir lo del ejercicio anterior: \inlinecode{git status} Como era de esperarse, se nos indica que uno de nuestros archivos ha sido modificado. Ahora, veremos en qu\'e ha cambiado. Para eso corremos el nuevo comando: \inlinecode{git diff}\\

Esto es m\'as interesante. Se nos dice qu\'e l\'ineas han cambiado en nuestro archivo. De hecho, se nos indica con un signo $-$ el estado anterior de esa l\'inea, y con un signo $+$ el nuevo estado de la misma. Podemos ir viendo, entonces, qu\'e cambios hemos hecho y d\'onde. Tambi\'en se nos dice en qu\'e archivo, si nos fijamos en las primeras l\'ineas de resultado. Si deseamos dejar esos cambios, agregamos el archivo con \emph{add}, como hab\'iamos visto antes. Si no, lo ignoramos.

\subsubsection{.gitignore}
Al crear programas nuevos es necesario ir prob\'andolos para asegurarse de que todo funcione bien. Cada vez que un programa se traduce al lenguaje de la compu y se ``ensambla'', se crean varios archivos auxiliares o de soporte, adem\'as del programa en versi\'on ya terminada. Claro, esto es importante a la hora de hacer pruebas, pero generalmente no queremos agregarlo a nuestra revisi\'on, ya que lo importante para nosotros es el c\'odigo fuente: lo que nosotros hemos escrito. Para ello, git nos ofrece un peque\~no truco: \inlinecode{.gitignore}\\

\inlinecode{.gitignore} es un archivo ``oculto'', como el directorio de git en nuestro directorio de trabajo, que nos ofrece la habilidad de ignorar ciertos archivos a la hora de registrar un estado del proyecto. C\'omo as\'i? Cada vez que creamos el registro de una nueva revisi\'on de nuestro proyecto, podemos ignorar algunos archivos (e.g. archivos auxiliares o programas semi-terminados) con el fin de solo ir guardando nuestro c\'odigo fuente. Hagamos un ejercicio con esto.\\

En nuestro directorio del proyecto vamos a crear un archivo nuevo y escribir algo en \'el, cualquier cosa. Luego, en la l\'inea de comando, abriremos el archivo con \inlinecode{nano} de la siguiente forma: \inlinecode{nano .gitignore}. All\'i vamos a agregar el nombre de nuestro nuevo archivo, precedido por una diagonal: \inlinecode{/mi\_archivo.txt}. Cerramos, guardamos y expliramos el estado de nuestro proyecto con \inlinecode{git status}. Inmadiatamente nos damos cuenta de que nuestro archivo no ha sido tomado en cuenta, pero \inlinecode{.gitignore} si. Agregamos este \'ultimo al registro de nuestra nueva revisi\'on y corremos \inlinecode{git commit -m "\ \hspace{-1em} Comenzando con .gitignore"} para guardarlo.

\subsection{Commit, Push, Pull y Log}
Una de las cosas m\'as interesantes que se pueden llevar a cabo con un sistema como git, es trabajar en grupo en un proyecto en particular. Esto significa que todos estar\'an realizando cambios sobre los mismos archivos y creando o eliminando cosas dentro del mismo proyecto. Es una buena pr\'actica que cada vez que alguien hace alg\'un cambio, se guarde y registre esa revisi\'on. Por ello, a continuaci\'on veremos c\'omo hacer operaciones como: registrar cambios, subir los cambios registrados a nuestra cuenta en GitHub, actualizar el proyecto con cambios de alguien m\'as y ver qu\'e cambios se han hecho en general.

\subsubsection{commit}
Algo que ya hemos hecho con anteriorirdad, aunque no hemos entendido muy bien qu\'e es lo que hace, es registrar cambios o \emph{commitear} cambios (dado que no existe una traducci\'on exacta para este verbo). La acci\'on de este comando es sencilla: est\'a guardando \textbf{solo los cambios realizados} en el proyecto. Esto lo hace en el directorio oculto que tiene nuestro proyecto. Sin embargo, esto solo sucede localmente! Los cambios solo se guardan en nuestro ordenador. Para que estos pasen a GitHub, veremos otro comando m\'as. La ventaja es que antes de empujar cambios a GitHub, podemos hacer cualquier cantidad de commits. Veamos qu\'e se requiere y c\'omo se hace esto.\\

El comando es relativamente sencillo cuando uno lo ve: \inlinecode{git commit}. Solo eso? S\'i, en esencia, s\'i. Si queremos entender qu\'e pasar\'a despu\'es, debemos entender algunas cosas sobre este comando. Cada vez que registramos un cambio nuevo, git nos pide que agreguemos un mensaje. La idea es explicar a grandes rasgos qu\'e se hizo, c\'omo y por qu\'e. Hay dos formas de incluir este mensaje:
\begin{enumerate}
\item Esperando que despu\'es de correr \inlinecode{git commit}, git inicie \inlinecode{nano} en donde escribiremos el mensaje.
\item Agregando, despu\'es de \inlinecode{git commit}, la bandera \inlinecode{-m} y nuestro mensaje entre comillas.
\end{enumerate}

Ahorita no hemos hecho ning\'un cambio en nuestros datos, as\'i que, intenta editar y cambiar el archivo que hab\'ias editado en la secci\'on de \textbf{diff} y vamos a realizar alg\'un otro cambio que podamos registrar. Cuando ya todo est\'e listo, vamos a correr \inlinecode{git commit}, vamos a ingresar un mensaje en \inlinecode{nano} y vamos a finalizar cerrando y guardando. Comenta, qu\'e ventajas y desventajas hay de usar la primera o la segunda forma?

\subsubsection{push}
Y finalmente llegamos al momento en el que todo se une. Todos los commits que hemos estado realizando, los hemos hecho localmente. Nos toca entonces empujar todas estas revisiones a GitHub. Para ello vamos a ingresar el siguiente comando: \inlinecode{git push} y lo vamos a correr. Si no hab\'ia cambios pendientes de registrar, se nos pedir\'a un usuario y una clave. Estos son los de GitHub. Finalmente, todos los cambios se guardar\'an en la nube y quedar\'an disponibles para colaboradores o usuarios de datos o el software en el que estamos trabajando.

\subsubsection{pull}
Ya que hemos aprendido a registrar cambios y empujar nuestras versiones a la nube, vamos a aprender c\'omo descargar esto para actualizar el proyecto en el que estamos trabajando, si que es este ha sufrido cambios por parte de alguien m\'as. Si se est\'a trabajando en un proyecto conjunto con otras personas, es muy com\'un que haya archivos sujetos a cambio constante por varios integrantes del equipo de desarrollo y por eso, necesitas saber qu\'e es diferente antes de empezar a trabajar.\\

Por eso, si estamos trabajando en un ambiente con m\'as personas, siempre debemos de actualizar nuestras revisiones primero, i.e. hacer un \emph{pull} o jalar cambios. Para esto, el comando es muy sencillo: \inlinecode{git pull}. Si hace eso ahorita con tus archivos actuales, es muy probable que git solo te diga que todo est\'a actualizado y no hay nada que jalar. Sin embargo, intentemos hacerlo, es un buen ejercicio!

\subsubsection{log}
Saber qu\'e ha pasado con nuestro proyecto a lo largo del tiempo resulta importante cuando sabemos que no solo nosotros hemos hecho cambios sobre \'el. Tambi\'en nos sirve para tener una idea del avance del proyecto. Para hacer una revisi\'on de esto, es muy \'util un peque\~no comando que veremos a continuaci\'on: \inlinecode{git log}. Intenta ingresar esto a tu l\'inea de comado y ver qu\'e te arroja como resultado. Por cierto, para salirte del log, presiona \emph{q}.\\

El \emph{log} es como el \'indice de nuestro cuaderno de laboratorio. En este se encuentran todos los commits hechos con un n\'umero particular: su identificador o \emph{id}. La identificaci\'on es importante! Cada commit tiene un \emph{id} que lo identifica, permiti\'endole a GitHub o a nuestro ordenador saber cu\'al es cu\'al. M\'as adelante veremos para qu\'e nos puede ser \'util.

\subsection{Ramas, Merge y Fork}
Hasta ahora hemos revisado nuestro proyecto por cambios, hemos registrado los cambios de una revisi\'on, hemos empujado esa informaci\'on, descargado actualizaciones y revisado el \'indice del proyecto. Git, sin embargo, permite hacer algunas cosas mucho m\'as interesantes. Una de ellas es la capacidad de trabajar en una versi\'on del proyecto independientemente del resto de \'el. Otra es integrar esos cambios independientes al proyecto principal. Y finalmente, otra ser\'ia copiar un proyecto entero para modificarlo, sin la necesidad de descargar todo y crear algo nuevo en GitHub. Revisemos cada una de estas opciones.

\subsubsection{branch}
Deseamos trabajar en un script de nuestro proyecto, pero trabajar en \'el implica hacer que funcione de otra forma por completo. Eso implica hacer cambios que afectan grandemente al proyecto, porque lo m\'as probable es que algunas personas del proyecto ya dependan de que ese script funcione. C\'omo hacemos eso conservando la habilidad de ir guardando registro de revisiones? Pues, se crea una rama. Una rama es como otro camino que seguiremos desde una revisi\'on espec\'ifica. C\'omo as\'i? Partiendo de un commit en particular, vamos a seguir por \emph{otro} camino que tendr\'a el desarrollo de una caracter\'istica en particular. Este desarrollo se estar\'a llevando a cabo en paralelo al desarrollo principal del proyecto, pero no lo tocar\'a. Esto es una rama, o \inlinecode{branch}. La representaci\'on gr\'afica de esto se ve algo as\'i.

\Picture{img/branch.png}

Aqu\'i podemos ver que cada peque\~no c\'irculo en las l\'ineas son commits, y notamos c\'omo es que 3 ramas se desprenden del proyecto principal (la l\'inea negra). La idea entonces es poder desarrollar una caracter\'istica en particular sin necesidad de arruinar el resto del proyecto. Lo primero que intentaremos ser\'a revisar qu\'e ramas existen y luego crearemos una nueva.\\

Para revisar qu\'e ramas existen, el comando es sencillo: \inlinecode{git branch}. Esto nos mostrar\'a la rama \inlinecode{*master}, que por el momento es la \'unica que existe. Ahora intentaremos crear una nueva rama y nos cambiarnos a ella. Para ello, vamos a ingresar lo siguiente en nuestra l\'inea de comando: \inlinecode{git branch \emph{nombre\_rama}}. Esto crear\'a la rama nueva. Para pasarnos a ella, ingresamos: \inlinecode{git checkout \emph{nombre\_rama}}. De esa forma no solo creamos la rama, sino nos situamos en ella. Para fines de practicidada, estos dos comandos se pueden fusionar en uno solo: \inlinecode{git checkout -b \emph{nombre\_rama}}. Despu\'es de haber hecho esto, piensa: C\'omo te regresas a la rama principal?

\subsubsection{merge}
Y qu\'e pasa cuando terminamos de modificar lo que quer\'iamos, nuestro nuevo c\'odigo funciona y lo queremos incluir en la rama principal de nuestro proyecto? En este caso, debemos de hacer que nuestra rama se una al proyecto principal. Para git, esto se hace con el comando \inlinecode{merge}. La idea es colocarnos en una rama particular y decirle a git que esta debe de unirse a otra rama que especificamos. La representaci\'on gr\'afica de esto se puede notar al observar c\'omo las ramas de colores verde, azul y algunas l\'ineas negras se unen a la l\'inea negra principal con una peque\~na flecha.\\

\Picture{img/merge.png}

As\'i que tomando eso en cuenta, solo parece l\'ogico que el comando completo sea algo as\'i \inlinecode{git merge master}.Con esto \'ultimo unir\'iamos nuestra nueva rama a la rama principal. Debemos de tener cuidado, pues es com\'un que el c\'odigo sobre el que estabamos trabajando vaya a haber sido modificado en el tiempo en que nosotros trabajamos en la rama. En ese caso, git nos advertir\'a que eso pas\'o y nos dar\'a la opci\'on de escoger una opci\'on. Eso, sin embargo, lo veremos m\'as adelante.

\subsubsection{fork}
Se da a veces el caso en el que alg\'un proyecto nos parece muy interesante. Por ejemplo, Linux es un proyecto que se trabaja con git. Algunas personas lo hallan muy interesante y desear\'ian crear una versi\'on personalizada y espec\'ifica de Linux para alguna necesidad. C\'omo hacer esto? Hacer una rama del proyecto principal de Linux no parece una buena idea; las ramas sirven para contribuir al proyecto. No, nosotros deseamos algo independiente. Para ello se dice que se hace un \inlinecode{fork} (as\'i como tenedor en ingl\'es). Y pues, la idea es hacer una replica exacta del repositorio de Linux dentro de nuestra cuenta personal de git. Esto nos ahorrar\'a descargar el proyecto entero, crear un repositorio en nuestra cuenta, registrarlo con el proyecto que descargamos y volver a empujar todo a la nube. En vez de eso, en GitHub, solo hacemos click al bot\'on del proyecto que deseamos copiar. Nada m\'as.

\Picture{img/fork.png}

\subsection{GUI y Situaciones Comunes}
Acept\'emoslo, la l\'inea de comando nos permite hacer muchas cosas, pero tenemos que memorizar muchas palabras y no resulta nada pr\'actica muchas veces. Por qu\'e no existen soluciones m\'as gr\'aficas? Con campos de texto, botones, deslizadores, ventanas, etc.? Pues ... la verdad es que s\'i existen. Facilitan mucho el trabajo y nos ayudan a poder desarrollar m\'as r\'apidamente. Por qu\'e no las usamos muy seguido? Porque nos limitan mucho; no nos ofrecen muchas de las opciones que hemos aprendido hasta ahora en el taller. Sin embargo, como nuestro objetivo no es ser programadores, sino saber usar un ordenador para hacer qu\'imica, vamos a dar una breve introducci\'on a \emph{un} ambiente gr\'afico para git: Cola.

\subsubsection{Cola Git}
Esta interfaz para git es relativamente sencilla e intuitiva. Al abrirla, hallamos que solo nos expondr\'a una ventana con 3 botones: \textbf{Abrir}, \textbf{Clonar} y \textbf{Cerrar}.

\Picture{img/cola1.png}

\textbf{Abrir} se refiere a apuntar a Cola a un directorio que ha sido iniciado o clonado de un proyecto git. Entonces Cola reconocer\'a esto y nos dir\'a en una ventana m\'as grande: qu\'e archivos han cambiado, nos ofrecer\'a agregarlos al commit, y si hacemos click en uno de ellos, en la parte inferior nos mostrar\'a qu\'e ha cambiado en ellos desde la \'ultima vez que se ha hecho commit. Desde ac\'a tambi\'en se puede realizar commits, se puede jalar y se puede empujar cambios.

\Picture{img/cola2.png}

Como ejercicio, intenta cambiar alg\'un archivo, realiza un commit y empuja cambios desde Cola.

\textbf{Clonar} se refiere a clonar un repositorio; un proyecto. Cola inmediatamente te pide una direcci\'on web de d\'onde descargar el proyecto, te pregunta a qu\'e directorio lo deseas descargar y te da la opci\'on de descargarlo a trav\'es de \'el.\\

Si lo notas, todo lo que puedes hacer con Cola, lo puedes hacer desde la l\'inea de comando. En el caso de Cola, puedes hacerlo quiz\'a m\'as r\'apido, pero la l\'inea de comando te permite hacer m\'as cambios y con mucho m\'as control.

\subsubsection{Deseo ver c\'omo estaban mis archivos en una revisi\'on particular}
No es tan com\'un como las dos siguientes, pero sin embargo, nos pasa. Deseamos ver qu\'e hab\'iamos escrito en determinado punto del proyecto o c\'omo se ve\'ia un archivo en particular porque ``entonces funcionaba, y ahora no''. Para hacer esto se trabaja de manera muy similar a las ramas, pero con un truco leve. Lo primero que debemos saber es el \emph{id} del commit que queremos revisar. Para eso es \'util usar \inlinecode{git log}. Una vez hallado el \emph{id}, entonces procedemos a situarnos en ese punto del proyecto mediante: \inlinecode{git checkout <id-commit>}. De esta forma llegamos a \textbf{ESE} momento en particular.\\

Ahora, resulta \'util hacer esto, pero ... y c\'omo regresamos? Aqu\'i vale la pena mencionar nuevamente el caso de la cabeza del proyecto: \inlinecode{HEAD}. Nosotros podemos navegar entre diferentes puntos del proyecto refiri\'endonos solamente a d\'onde se halla la cabeza o a qu\'e distancia de la cabeza se halla alg\'un commit. Para regresar a la cabeza, el comando es sencillo: \inlinecode{git checkout HEAD}. Sin embargo, mencionamos lo dem\'as, porque para movernos a un commit en particular, a veces no es necesario el \emph{id}. El commit anterior a la cabeza se llama \inlinecode{HEAD$\sim$1}, el anterior a ese \inlinecode{HEAD$\sim$2}, el anterior a ese \inlinecode{HEAD$\sim$3} y as\'i sucesivamente. De esta manera, si deseamos retroceder 5 pasos, solo debemos de ingresar \inlinecode{HEAD$\sim$5} a la l\'inea de comando y \emph{voil\'a}, hemos llegado!

\subsubsection{Hice commit de cambios que no deseo en GitHub}
Para este problema, existen dos soluciones. La primera es responsabilizarse por el error y dejarlo all\'i para la posteridad. La segunda es decirle a git que ignore eso y borre lo que acabas de registrar. Si se dice que la \emph{cabeza} del sistema de revisiones es el \'ultimo commit en haber sido agregado, esta acci\'on de ignorar lo que acabas de hacer y borrar todo desde cierto punto en adelante se conoce como mover la cabeza hasta X punto (en donde X es el identificador del commit hecho). Hacer esto es \textbf{MUY} peligroso y no se recomienda, porque se perder\'an los cambios de todos a partir del commit escogido como nueva cabeza. Sin embargo, esta es una pregunta com\'un y por eso dejaremos el c\'digo para hacerlo: \inlinecode{git reset --hard <id-commit>} Si ya empujaste los cambios que no deseabas a GitHub, hay algunas maneras de eliminar los commits hechos, pero no se cubrir\'an aqu\'i.

\subsubsection{Ambos editamos el mismo archivo en el mismo lugar}
Es com\'un, aunque a pocos les guste, que dos personas cambien el mismo archivo al mismo tiempo. Una intenta hacer \inlinecode{pull} antes de registrar cambios y resulta que BAM! hay un choque! Git nos avisa que el mismo archivo ha sido editado en las mismas l\'ineas. Que desastre! Y ahora, qu\'e debemos hacer? Pues la verdad, este asunto se resuelve de una manera bastante simple. Git nos permite ignorar cambios, o escoger cu\'al deseamos mantener y cual desechar. Hay herramientas especializadas para esto como KDiff. Este programa nos permite ver el c\'odigo antes de ser editado, la edici\'on de una persona, y la nuestra a modo de ver los cambios y escoger cu\'ales se quedan.

\subsection{Comentarios Finales}
Si observamos bien, no hicimos ning\'un ejercicio grande y especial con git. Esto se debe a que este sistema no sirve para hacer algo muy interesante dentro de un proyecto, m\'as que organizarlo y mantener copias de seguridad de cada paso en el desarrollo de un proyecto. M\'as adelante en el taller, vamos a continuar utilizando git a modo de ir guardando nuestros avances y practicar su uso.\\

Por ahora, felicidades! Has completado la introducci\'on al uso de un sistema de control de revisiones. Si deseas profundizar en el tema, se te recomienda hacerlo. Saber usar a mayor profundidad las ventajas que te ofrece git es algo de lo que jam\'as te arrepentir\'as. Y pues claro, llevar un registro decente y ordenado es una buena pr\'actica en toda ciencia.\\

Felicidades de nuevo, y \'animo! Ahora toca aprender a utilizar una herramienta que har\'a que tus reportes nunca vuelvan a ser iguales.

\newpage
\section{Ejercicios con \LaTeX\ }
Los reportes son una de las cosas con las que m\'as nos topamos tanto en un ambiente acad\'emico, como en uno laboral. Si no estamos tratando de explicar por qu\'e no nos sali\'o el producto en la s\'intesis, estamos buscando c\'omo ligar la evidencia de un an\'alisis y que eso nos lleve a una explicaci\'on. Sin embargo, siempre debemos documentar cada paso. Sin embargo, hay una cosa que suele quitarnos m\'as de nuestro preciado tiempo: el formato. Cuando comenz\'abamos a hacer reportes en los primeros a\~nos fuimos ingenuos y los hicimos todos desde cero. Adem\'as, muchas veces nos los pidieron a hechos a mano. Luego ya no fue as\'i, pero cada instructor o catedr\'atico nos los ped\'ia diferentes. Al final de cuentas siempre result\'abamos haciendo una plantilla para ese laboratorio y la segu\'iamos usando todo el semestre. Si bien nos iba, la plantilla era buena y agregarle cosas no nos arruinaba cosas como la numeraci\'on de las p\'aginas o la colocaci\'on de las im\'agenes, pero si no, nos iba a tomar unos 20 minutos arreglar el problema. Adem\'as de esto, ni nuestros proyectos, ni nuestros reportes se vieron profesionales. Acept\'emoslo, nunca se hab\'ian visto como un art\'iculo cient\'ifico, como un peque\~no manual o como un libro. ``Eso es trabajo de una editorial.''--pensar\'ian algunos. Pero hoy vamos a ver que no, y que hacer trabajos con un acabado de editorial no es nada complicado.\\

Hace ya varios a\~nos se intent\'o crear un programa que facilitara la impresi\'on de documentos en cualquier tipo de impresora; desde impresoras de matriz hasta impresoras laser. Este programa se hizo llamar \TeX\ y su desarrollo llev\'o a que sea utilizado por editoriales grandes hasta nuestros d\'ias. El ``dialecto'' m\'as utilizado de \TeX\ hoy d\'ia es llamado \LaTeX\ . Este result\'o siendo el lenguaje de programaci\'on adoptado por la comunidad cient\'ifica en muchas partes por sus ventajas para crear plantillas, escribir ecuaciones, numerarlas, insertar bibliograf\'ias, autonumerar p\'aginas, etc. Se dice que es un lenguaje de programaci\'on como HTML, pues se basa en peque\~nas palabras indicando las diferentes partes del documento. Y la idea final es obtener un documento que no solo tenga un contenido ideal, como solemos inclu\'irselos a nuestros proyectos, sino que se vea excepcional sin tener que invertir mucho tiempo en darle formato. Pero para qu\'e explicar lo bien que se puede ver un documento de estos? Es un poco redundante. El documento que estamos viendo fue hecho en \LaTeX\ , al igual que el de ayer, anteayer y el de los dem\'as d\'ias. Pero la idea no es que lo sepamos identificar en un documento, sino que lo sepamos usar. Comencemos, pues, a crear nuestros documentos de una forma diferente!

\subsection{Comenzando con un Proyecto}
Para trabajar con \LaTeX\ suele no hacer falta nada m\'as que un editor de texto y saber c\'omo crear un archivo \emph{PDF} a partir del archivo \TeX . Sin embargo, siendo \LaTeX\ tan extenso, vamos a utilizar un editor en espec\'ifico. Con este podremos ahorrarnos muchos problemas a la hora de crear nuestros documentos. Como primer paso, vamos a abrir \textbf{\TeX Maker} y all\'i vamos crear un documento nuevo. Este nuevo archivo en blanco lo vamos a guardar como \emph{proyecto\_01.tex}. Ahora vamos a iniciar con nuestro proyecto.\\

Vamos a iniciar el documento escribiendo:
\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}

\begin{document}

\end{document}
\end{verbatim}
\end{Code}

Aqu\'i iniciamos especificando el tama\~no de letra que se utilizar\'a en todo el documento, y el tama\~no de p\'agina con el que se trabajar\'a. Finalmente, en la primera l\'inea vemos que se especifica que vamos a crear un art\'iculo. Hay otras opciones como \inlinecode{letter}, \inlinecode{report} y \inlinecode{book}. La diferencia entre ellos son los comandos y la forma de aplicar el formato (el libro utiliza cap\'itulos, la carta solicita encabezados, fechas y firma, el reporte es como un informe final de proyecto, etc). Luego especificamos en d\'onde deseamos tener el contenido del documento: entre el inicio y el final del documento. All\'i dentro vamos a poner el contenido del archivo \emph{lorem\_ipsu.txt} (c\'opialo y p\'egalo). Luego, en la barra superior de \textbf{\TeX Maker} vas a hallar dos flechas azul claro. A la par de la primera debe de decir PDFLaTeX y a la par de la segunda debe decir View PDF. La idea all\'i es tener configurada la parte que nos permitir\'a transformar nuestro archivo \TeX\ en un PDF y poder visualizarlo despu\'es.

\Picture{img/tex_01.png}

Cuando esas dos cosas ya est\'en como en la im\'agen, podemos presionar la primera flecha azul. En la barra de abajo deber\'ia de aparecer algo que nos diga que el proceso ha terminado exitosamente. Ahora presionaremos la segunda flecha azul y el resultado nos ser\'a revelado: un documento escrito con un estilo bastante limpio y hasta con p\'aginas numeradas. Genial! Ahora ... hay ciertas cosas que no se ven muy bien. En primer lugar, vamos a agregar espacios entre p\'arrafos. Para ello, agregaremos dos diagonales inversas \inlinecode{\textbackslash \textbackslash } al terminar de cada p\'arrafo: despu\'es del punto y volvemos a presionar ambas flechas.\\

Ahora ya separamos los p\'arrafos y nuestro documento ya se ve mejor. Antes de proceder a la siguiente secci\'on repasemos en lo que hicimos. Inicializamos un documento especificando un tama\~no de letra y de p\'agina. Luego colocamos algo de texto dentro de \'el y finalmente separamos los p\'arrafos con una diagonal doble inversa. No es tan complicado, aunque s\'i requiere un poco de tiempo. Pero lo m\'as importante: no se ve como nosotros queremos que se vea. Para ello, vamos a continuar.

\subsubsection{Geometr\'ia}

Hasta ahora, si pensamos en c\'omo se ve nuestro documento, vamos a notar que los m\'argenes son muy grandes. Generalmente esto es algo que solo cambiamos cuando deseamos que la cantidad de p\'aginas en nuestros proyectos sea mayor o menor. En este caso, sin embargo, estamos desperdiciando demasiado espacio en los m\'argenes. C\'omo corregimos eso? La forma de cambiar m\'argenes en \LaTeX\ es m\'as sencilla de lo que uno se imagina, y suele hacerse siempre al inicio de los documentos que vayamos a producir. En nuestro caso, dejaremos m\'argenes de $2cm$ mediante el uso del paquete \inlinecode{geometry}. El resultado ser\'a algo as\'i:

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\begin{document}

Lorem ipsum dolor ...

\end{document}
\end{verbatim}
\end{Code}

Al volver a correr esto con las dos flechas azules, nos damos cuenta de que nuestro resultado es mucho mejor. Ya se nota que tiene un toque de documento. Y la mejor parte es que \LaTeX\ usa sangr\'ias en cada p\'arrafo y los deja justificados a\'un utilizando guiones! Se ve bastante bien.

\subsubsection{Idiomas}

Ahora agregaremos un par de paquetes m\'as que nos permitir\'an escribir lo que nosotros querramos dentro de nuestro documento. Y es que \LaTeX\ fue dise\~nado originalmente para el idioma ingl\'es. Un ejemplo de eso es que \textbf{las tildes} y \textbf{la \~n} no las podemos escribir f\'acilmente. Pero m\'as que eso, los guiones para dividir una palabra son importantes. Para ello, vamos a agregar otro paquete en el documento que llevamos.

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[spanish]{babel}

\begin{document}

Lorem ipsum dolor ...

\end{document}
\end{verbatim}
\end{Code}

Con esto ya muchas cosas se nos permiten en espa\~nol. M\'as adelante vamos a ver qu\'e impacto tiene realmente eso. Ahora, vamos a ver dos alternativas para lograr escribir las tildes y la \~n. La forma \emph{complicada} de escribirlas en \LaTeX\ es as\'i:

\begin{Code}
\begin{verbatim}
\'a
\'e
\'i
\'o
\'u
\~n
\end{verbatim}
\end{Code}

Ahora, a pesar de que parece bastante tedioso escribir de esa manera, es la \'unica infalible. Aunque el documento est\'e configurado para ingl\'es, esto garantiza que podamos tener tildes y \~ns. La otra forma de hacerlo sin complicarnos tanto la vida es incluyendo otro paquete en nuestro documento: un conjunto de caracteres universal.

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\begin{document}

Lorem ipsum dolor ...

\end{document}
\end{verbatim}
\end{Code}

Con este paquete ya no necesitamos estar usando el gui\'on y las ap\'ostrofes, sino que podemos escribir libremente y no habr\'an problemas. En este caso en particular, estos documentos est\'an escritos de la primera manera para garantizar que quien no posea el paquete en su ordenador, pueda de todas formas armar estos documentos. Sin embargo, la brecha de idiomas ya la cubrimos. Ahora solo vamos a profundizar en una \'ultima cosa: paquetes.\\

\subsubsection{Paquetes}

Los paquetes son formas de extender las funciones normales de \LaTeX . Como ya hemos visto, usamos paquetes para los m\'argenes, para el conjunto de caracteres permitidos y para idioma. Existen paquetes para muchas otras cosas m\'as. La sintaxis para incluirlos, sin embargo, es siempre la misma: \inlinecode{\textbackslash usepackage\{\emph{paquete}\}}\\

Todav\'ia vamos a ver aqu\'i un paquete m\'as: encabezados y pies de p\'agina. Este nos dar\'a una idea de qu\'e hacer y c\'omo darle una forma m\'as elegante a nuestros documentos.\\

\subsubsection{Encabezado y Pie}

El encabezado y pie de p\'agina suele ser todo un rollo en Microsoft Word. Estos suelen necesitar mucha configuraci\'on y bastante paciencia. En \LaTeX\ el asunto no es tan diferente, pero veremos que existen algunas diferencias que nos facilitar\'an el proceso. Comencemos importando el paquete que nos permitir\'a hacer el encabezado y el pie.\\

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}

\begin{document}

Lorem ipsum dolor ...

\end{document}
\end{verbatim}
\end{Code}

Si ponemos atenci\'on, notaremos que no solo incluimos un paquete, sino que le pedimos un estilo particular a la p\'agina. Lo que hace esto es que construye un estilo de encabezado y pies de p\'agina basados en el n\'umero de la p\'agina y en la secci\'on o cap\'itulo que se halle en esa p\'agina. Ahorita aunque re-armemos nuestro PDF no lo notaremos (solo notaremos una delgada l\'inea en el encabezado), pero en la siguiente secci\'on esto se har\'a evidente.

\subsection{Decorando el Documento}
\subsubsection{T\'itulo}
Ahora que ya tenemos un formato general para nuestro documento, lo vamos a comenzar a decorar un poco. Lo primero que vamos a agregarle ser\'a un t\'itulo. Pero para eso necesitamos especificar 2 cosas: el autor y el t\'itulo de nuestro trabajo. En este caso, el autor vamos a ser nosotros mismos y el t\'itulo ser\'a: Lorem Ipsum. El c\'odigo se ver\'a ahora algo as\'i:

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\author{Mi Nombre}
\title{Lorem Ipsum}

\begin{document}

\maketitle

Lorem ipsum dolor ...

\end{document}
\end{verbatim}
\end{Code}

Notemos que dentro del documento incluimos una peque\~na palabra nueva: \inlinecode{\textbackslash maketitle} Es justo aqu\'i que el t\'itulo es incluido dentro de nuestro documento. Si no lo incluimos, ninguna de las otras 2 entradas tienen sentido. El resultado, al armar nuestro documento en PDF es algo vistoso, pero cumple con lo que dese\'abamos. Adem\'as, incluye la fecha actual en espa\~nol (otra cosa que sale de usar el paquete para espa\~nol). Es importante darnos cuenta de que al incluir el t\'itulo, el encabezado ya no apareci\'o en esa p\'agina! Y hablando de encabezados, vamos a pasar a otra cosa que nos sirve de mucho al elaborar un documento nuevo.

\subsubsection{Secciones y Cap\'itulos}
Dividir un documento en diferentes partes suele hacerlo m\'as f\'acil de leer adem\'as de hacerlo m\'as f\'acil de referenciar. \LaTeX\ suele requerir que nosotros indiquemos d\'onde hay cap\'itulos y/o secciones para poder as\'i armar \'indices o sacar referencias. Antes de comenzar vamos a aclarar algo: Las secciones pueden ser utilizadas en cualquier documento. Los cap\'itulos solo pueden ser usados en reportes o libros.\\

En este caso estamos trabajando con un art\'iculo, as\'i que vamos a agregarle diferentes secciones a nuestro documento. Pero para que se note la diferencia, vamos a agregar m\'as texto. Vamos a abrir todos los documentos \emph{ipsum} en nuestro directorio y los vamos a agregar con sus respectivos nombres como secciones (recuerda separar los p\'arrafos):

\begin{Code}
\begin{verbatim}
\documentclass[12pt,letterpaper]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\author{Mi Nombre}
\title{Lorem Ipsum}

\begin{document}

\maketitle

\section{Lorem Ipsum}
Lorem ipsum dolor sit amet ...

\section{Bacon Ipsum}
Bacon ipsum dolor sit amet corned beef ...

\section{Cupcacke Ipsum}
Cupcake ipsum dolor sit amet candy canes ...

\section{Hipster Ipsum}
Before they sold out swag Pitchfork roof ...

\section{Tuna Ipsum}
Squaretail; ghost flathead hatchetfish ...

\section{Veggie Ipsum}
Veggies es bonus vobis, proinde vos postulo ...

\end{document}
\end{verbatim}
\end{Code}

Ahora s\'i que se ha vuelto grande nuestro documento! Pero m\'as que eso, notemos algo importante: las \emph{secciones} se colocan como t\'itulos exactamente donde las pusimos. Adem\'as de esto, el encabezado toma ahora el nombre de la \textbf{\'ultima} secci\'on que comienza en esa p\'agina en particular. Es recomendable bajarle el tama\~no de letra a 11 al documento para visualizar mejor estos cambios.\\

Un detalle que vale la pena mencionar es que las secciones no necesariamente tienen que tener un n\'umero. Si creamos una secci\'on mediante \inlinecode{\textbackslash section\{\emph{Nombre de la Secci\'on}\}} esta va a aparecer numerada. Si en vez de eso la creamos mediante \inlinecode{\textbackslash section*\{\emph{Nombre de la Secci\'on}\}} esta no aparecer\'a numerada, sino que solo aparecer\'a el t\'itulo de la misma.\\

En un documento de regular tama\~no, tener secciones a veces no es suficiente. Necesitamos tener divisiones adentro de las secciones. Para este tipo de casos, \LaTeX\ ofrece las sub-secciones, las sub-sub-secciones y las sub-sub-sub-secciones (estas \'ultimas no siempre van a comportarse como se esperar\'ia). Estas obedecen los mismos principios que las secciones: se autonumeran, se colocan como t\'itulos de un segmento del documento, y si se les agrega el asterisco en su creaci\'on, la numeraci\'on no aparecer\'a. Estas se crean de la siguiente manera:

\begin{Code}
\begin{verbatim}
\section{Nombre de la seccion}
\subsection{Nombre de la sub-seccion}
\subsubsection{Nombre de la sub-sub-seccion}
\subsubsubsection{Nombre de la sub-sub-sub-seccion}
\end{verbatim}
\end{Code}

Usa cada nivel sabiamente. Dividir un documento es bueno, pero dividirlo demasiado puede llevar a problemas de lectura o a que el contenido se vea disminuido. Ahora, ya que hemos visto c\'omo crear, darle forma y escribir en un documento \TeX , vamos a pasar a otro caso un poco diferente. Para esto guarda el trabajo que tengas, ci\'erralo y abre un documento nuevo en \textbf{\TeX Maker}. Ahora vamos a ver lo realmente bonito de \LaTeX .

\subsection{Notaci\'on Cient\'ifica}
Una de las caracter\'isticas tan especiales de \LaTeX\ es que se puede utilizar para ciencia. No solo por su formalidad y transparencia a la hora de crear documentos (no suceden cosas raras porque el programa lo quiso as\'i), sino porque se puede incluir notaci\'on cient\'ifica en ellos. Esta es una de la razones principales por las que se prefiere utilizar este lenguaje para textos cient\'ificos.\\

Para comenzar, vamos a hacer que nuestro nuevo documento sea un art\'iculo de letra tama\~no 10, m\'argenes sin alterar, en espa\~nol, con un grupo de caracteres que acepte tildes y \~n, sin encabezados bonitos, pero con un t\'itulo: \emph{Notaci\'on Cient\'ifica} y escrito nada m\'as que por nosotros. Cuando ya tengamos esto listo, podemos proceder a seguir leyendo.\\

Bueno, una vez ya tengamos listo un documeto as\'i, vamos a agregarle unos cuantos paquetes extra a nuestro documento. Estos paquetes \textbf{NO} son indispensables, pero ayudan mucho cuando se trata de notaci\'on cient\'ifica. Estos son:

\begin{Code}
\begin{verbatim}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\end{verbatim}
\end{Code}

\noindent Al agregar esto, nuestro c\'odigo ha de verse algo as\'i:

\begin{Code}
\begin{verbatim}
\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Mi Nombre}
\title{Notaci\'on Cient\'ifica}

\begin{document}

\maketitle

\end{document}
\end{verbatim}
\end{Code}

Ahora podemos comenzar a utilizar la notaci\'on cient\'ifica en nuestro documento. Como esta puede comprender muchos \'areas, vamos a ir paso a paso como cuando se comienza a aprender matem\'atica. Lo primero que vamos a aprender es a preparar un lugar en nuestro documento d\'onde colocar esta notaci\'on. Si deseamos que los s\'imbolos o notaci\'on aparezcan dentro del texto, como esto: $H_2 CO_3 \longrightarrow^{\hspace{-0.4cm} \Delta}\hspace{0.2cm} H_2 O + CO_2$, entonces utilizamos los signos de dolar al iniciar y finalizar una expresi\'on: \inlinecode{\$ \emph{expresi\'on} \$}. A esta forma de notaci\'on se le llama \emph{inline}. La otra forma de incluir notaci\'on cient\'ifica es declarando un segmento como de ecuaci\'on de esta manera:

\begin{Code}
\begin{verbatim}
\begin{equation}

expresion

\end{equation}
\end{verbatim}
\end{Code}

\noindent A un segmento as\'i en \LaTeX\ (declarado con un principio y un final) se le llama \emph{ambiente}. El resultado se ver\'a as\'i:

\begin{equation}
H_2 CO_3 \longrightarrow^{\hspace{-0.4cm} \Delta}\hspace{0.2cm} H_2 O + CO_2
\end{equation}

Algo que podemos notar de inmediato es que la forma en que se muestra la reacci\'on es ahora m\'as limpia, centrada y (muy importante) numerada. S\'i, \LaTeX\ autonumera nuestras ecuaciones, reacciones o f\'ormulas por defecto. Esto nos permite referirnos a ellas dentro del documento posteriormente. Vamos a crear una nueva secci\'on dentro de nuestro documento de notaci\'on cient\'ifica a la que llamaremos \emph{Operaciones B\'asicas}. En ella vamos a explicarle a alguien m\'as c\'omo se suma, resta, multiplica y divide en \LaTeX . La descripci\'on es cosa nuestra; nos toca ponernos creativos. Lo que s\'i vamos a ver es c\'omo se hacen estas operaciones. Probemos irlas incluyendo dentro de nuestra explicaci\'on de manera \emph{inline} para mantener la continuidad del texto.

\begin{Code}
\begin{verbatim}
Sumar:       $ A + B = C $
Restar:      $ D - E = F $
Multiplicar: $ G \cdot H = I $
Dividir:     $ \frac{J}{K} = L $
\end{verbatim}
\end{Code}

Al final generemos nuestro PDF para ver c\'omo se ve el resultado. Ahora mostr\'emoselo a nuestro compa\~nero de al lado y discutamos sobre lo que ambos creen que hace cada parte de lo que hemos visto. Una vez terminado esto, vamos a pasar a otra parte m\'as intensa. Vamos a crear otra nueva secci\'on de nuestro documento llamada \emph{\'Algebra}. Aqu\'i vamos a explicar que el uso de notaci\'on cient\'ifica dentro de un texto lo puede hacer m\'as comprensible al lector. Como ejemplo vamos a proponer la f\'ormula de Vieta, la cual nos sirve para calcular las dos ra\'ices de un polinomio de grado dos.

\begin{equation}
x_{1,2} = \frac{-B \pm \sqrt{B^2 - 4 A C}}{2 A}
\end{equation}
 \\

Y que en el caso de que $ B^2 - 4 A C > 0 $ entonces $ x_{1,2} \in \mathbb{R} $, o que en el caso en que $ B^2 - 4 A C = 0 $ entonces $ x \in \mathbb{R} $. Pero si $ B^2 - 4 A C < 0 $ entonces $ x_{1,2} \in \mathbb{C} $. Esta explicaci\'on quiz\'a nos tome un rato, pero para ayudarnos se nos dej\'o aqu\'i la manera en que se representan cada una de estas operaciones y relaciones.

\begin{Code}
\begin{verbatim}
Potencias:     $ A^{3} = A \cdot A \cdot A $
Raiz cuadrada: $ \sqrt{B} = B^{1/2} $
Raiz radical:  $ \sqrt[n]{C} = C^{1/n} $
Subindices:    $ D_{2} = $ deuterio molecular
Mayor igual:   $ E \geq F $
Menor igual:   $ G \leq H $
Mayor y menor: $ I > J < K | I = 1, K = 2, J = -5 $
Mas-menos:     $ \sqrt{4} = \pm 2 $
Conjuntos:     $ \mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{I}, \mathbb{R}, \mathbb{C} $
Pertenece a:   $ 1, 2, 3, \ldots \in \mathbb{N} $
Para todo:     $ \forall n \in \mathbb{N} | n^{2} \geq n $
No existe:     $ \frac{x}{0} = \nexists $
\end{verbatim}
\end{Code}

Se nos recomienda probar cada una de las expresiones que se nos han dado antes de utilizarla dentro de nuestra explicaci\'on; esto nos dar\'a una mejor idea de c\'omo se ver\'a el resultado o qu\'e significa cada secuencia, palabra y signo. Como antes, al terminar nuestra explicaci\'on, vamos a mostr\'arsela a nuestro compa\~nero de a la par y vamos a corroborar que nuestras explicaciones sean correctas. Por cierto, la secuencia \inlinecode{\textbackslash ldots} es la que nos da tres puntos suspensivos.\\

Antes de pasar a la siguiente secci\'on hay un peque\~no truco que utilizamos en \'algebra que no hemos visto todav\'ia: par\'entesis. Los par\'entesis no son algo complicado en \LaTeX , sin embargo, s\'i se debe saber c\'omo llamarlos, pues de hacerlo mal estos no se comportar\'an como nosotros deseamos. Lo \'unico importante que debemos tomar en cuenta a la hora de usar par\'entesis es lo siguiente:\\
\noindent\inlinecode{\textbackslash left\#} declara un par\'entesis que ir\'a a la izquierda\\
\noindent\inlinecode{\textbackslash right\#} declara un par\'entesis que ir\'a a la derecha\\

Claro que en vez del numeral \inlinecode{\#} debe ir el tipo de par\'entesis que deseamos. Los ejemplos claros est\'an a continuaci\'on.

\begin{Code}
\begin{verbatim}
(a + b):        $ \left( a + b \right) $
[x, y]:         $ \left[ x , y \right] $
<i, j>:         $ \left\langle i , j \right\rangle $
{1, 2, 3, ...}: $ \left\lbrace 1 , 2 , 3 , \ldots \right\rbrace $
\end{verbatim}
\end{Code}

Debemos de tener especial atenci\'on con las llaves y los par\'entesis angulares, porque estos no utilizan un signo en vez del numeral, sino otra secuencia. Fuera de eso, la idea en todos los casos es igual. Agreguemos esto a nuestra explicaci\'on en nuestro documento sobre notaci\'on cient\'ifica y discutamos con otro compa\~nero sobre nuestras conclusiones.\\

A continuaci\'on vamos a crear una secci\'on m\'as en nuestro documento. Esta se llamar\'a \emph{C\'alculo}. En esta secci\'on vamos a profundizar en los \'ultimos toques de matem\'atica. En nuestro documento vamos a explicar dos casos en particular, y luego nos vamos a extender con algunos detalles extra. Lo primero que vamos a explicar es c\'omo escribir la definici\'on de una derivada.

\begin{equation}
f' \left( x \right) = \lim_{h \to \infty} \frac{f \left( x + h \right) - f \left( x \right) }{h} = \dfrac{d}{d x} f \left( x \right)
\end{equation}
 \\

Luego, para complementar un poco m\'as las cosas, pasaremos a explicar c\'omo se escribe una integral desde su definici\'on. Recordemos que $\Delta x = \frac{b - a}{n}$ y que $x_{i}^{*} = a + (\Delta x) \cdot i$. Luego procedemos con la definici\'on:

\begin{equation}
A = F \left( b \right) - F \left( a \right) = \lim_{n \to \infty} \sum_{i = 1}^{n} \left( f\left(x^{*}_{i}\right) \cdot \Delta x \right) = \int_{a}^{b} f \left( x \right) dx
\end{equation}
 \\

Otra vez resultamos con cosas que nos parecen un poco monstruosas, pero no nos dejemos enga\~nar por pas apariencias. La mayor parte de lo que tenemos aqu\'i ya lo sabemos hacer. Lo \'unico nuevo son: los l\'imites, la derivada, la sumatoria y la integral. Esas se construyen de la siguiente manera:

\begin{Code}
\begin{verbatim}
Sumatoria: $ \sum_{ i = 0 }^{ n } i = \frac{ n \left( n + 1 \right) }{ 2 } $
Limite:    $ \lim_{ x \to 0^{+} } \log(x) = - \infty  $
Derivada:  $ \dfrac{ d }{ d x } f = f' $
Integral:  $ \int_{ - \infty }^{ \infty } e^{ -x^{2} } dx = \sqrt{ \pi } $
\end{verbatim}
\end{Code}

A pesar de que se mostraron entre los signos de dolar, es \textbf{muy} recomendable que estos signos no se utilicen como texto \emph{inline}, sino que dentro del ambiente de ecuaciones; all\'i se aprecian mejor. Para cuando hagamos nuestras pruebas, intentemos hacerlo as\'i. Ahora, entre las nuevas secuencias que hemos visto, la de derivada es una que se parece mucho a la de fracciones, pero tenemos que ponerle atenci\'on a esa \emph{d}; tiene su raz\'on de ir all\'i. Por otra parte, qu\'e pasar\'ia si nuestra derivada es parcial? Pues usamos \inlinecode{\textbackslash partial} en vez de \inlinecode{d} Y si deseamos hacer derivadas en varias dimensiones de una vez, podemos utilizar \inlinecode{\textbackslash nabla}. De esta forma ya podemos escribir cosas como:

\begin{equation}
\nabla^2 \psi = \dfrac{\partial^2 \psi}{\partial x^2} + \dfrac{\partial^2 \psi}{\partial y^2} + \dfrac{\partial^2 \psi}{\partial z^2}
\end{equation}

Esto \'ultimo nos lleva a considerar algo: todas las letras griegas existen en \LaTeX . Lo que hay que saber para utilizarlas es su secuencia, que en este caso es el nombre de cada una de ellas. Cuando se desean min\'usculas, la secuencia va toda en min\'usculas. Cuando se desea una may\'uscula, la primera letra de la secuencia debe escribirse en may\'uscula.\\

Finalmente, vamos a crear una secci\'on m\'as en nuestro documento: \emph{Qu\'imica}. Lo primero que hicimos en este segmento vamos a intentar repetirlo aqu\'i: la reacci\'on de descomposici\'on del \'acido carb\'onico. Antes de que nos den el c\'odigo con el que se hace eso, propongamos una forma de hacerlo con lo que ya sabemos.

Reacci\'on

Radio decay

Termo

Cuantica

\subsection{Im\'agenes y Tablas}
\subsection{Art\'iculo Cient\'ifico}
\subsection{Autoensablados: \'Indice y Bibliograf\'ia}
\subsection{Tesis}

\subsection{Comentarios Finales}

\section{Glosario de comandos sencillos}
\subsection{Git}
\begin{small}
\begin{itemize}
\item \textbf{git config}: configura git con tu nombre, tu direcci\'on de correo y tu editor de texto preferido.
\item \textbf{git init}: inicia un nuevo proyecto en git de manera local; un nuevo repositorio.
\item \textbf{git clone}: descarga los contenidos de un repositorio ya existente a tu ordenador y los deja listos para poder trabajar con ellos.
\item \textbf{git status}: revisa el estado actual de los archivos en el repositorio en comparaci\'on al \'ultimo commit.
\item \textbf{git diff}: muestra claramente las diferencias entre el estado actual de los archivos en el repositorio con respecto al \'ultimo commit. Muestra las diferencias l\'inea por l\'inea.
\item \textbf{.gitignore}: archivo que contiene el listado de todos los archivos del proyecto que deben ser ignorados por git.
\item \textbf{git commit}: guarda los cambios realizados a los archivos como una revisi\'on. Crea un registro y un \emph{id} que identifica a esa revisi\'on.
\item \textbf{git push}: empuja (sube) los commits locales a GitHub.
\item \textbf{git pull}: jala (descarga) los archivos del proyecto en GitHub, actualizando el estado de estos en nuestro ordenador.
\item \textbf{git log}: muestra toda la actividad de commits que ha habido en un repositorio/proyecto.
\item \textbf{git branch}: muestra a todas las ramas existentes o, si se le agrega un nombre despu\'es del comando, se crea una rama nueva en el proyecto.
\item \textbf{git merge}: une a una rama existente con otra rama que se debe de especificar como argumento del comando.
\item \textbf{git checkout}: si como argumento se agrega el nombre de una rama, se habr\'a trasladado a esa rama. Si como argumento se agrega el \emph{id} de un commit o la distancia de la cabeza a un commit con \inlinecode{HEAD$\sim$\#}, entonces nos situaremos en el commit seleccionado y podremos ver el estado del proyecto en ese momento.
\end{itemize}
\end{small}

\subsection{\LaTeX\ }
\begin{small}
\begin{itemize}
\item 
\end{itemize}
\end{small}

\end{document}
